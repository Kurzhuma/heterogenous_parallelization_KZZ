//
// Practice lab 3
//


// Подключаем стандартный контейнер vector
#include <vector>

// Подключаем заголовочный файл с объявлениями сортировок
#include "sorting.h"

//
// ======================= MERGE SORT =======================
//

// Объявляем статическую функцию для слияния двух отсортированных частей массива
static void merge(std::vector<int>& arr, int l, int m, int r)
// Начало функции merge
{
    // Вычисляем количество элементов в левой части массива
    int n1 = m - l + 1;

    // Вычисляем количество элементов в правой части массива
    int n2 = r - m;

    // Создаём временный массив для левой части
    std::vector<int> L(n1);

    // Создаём временный массив для правой части
    std::vector<int> R(n2);

    // Запускаем цикл копирования элементов левой части
    for (int i = 0; i < n1; ++i)
    // Тело цикла копирования левой части
    {
        // Копируем элемент из исходного массива в левый временный массив
        L[i] = arr[l + i];
    }

    // Запускаем цикл копирования элементов правой части
    for (int j = 0; j < n2; ++j)
    // Тело цикла копирования правой части
    {
        // Копируем элемент из исходного массива в правый временный массив
        R[j] = arr[m + 1 + j];
    }

    // Инициализируем индекс для левого массива
    int i = 0;

    // Инициализируем индекс для правого массива
    int j = 0;

    // Инициализируем индекс для исходного массива
    int k = l;

    // Выполняем слияние двух массивов, пока элементы есть в обоих
    while (i < n1 && j < n2)
    // Тело цикла слияния
    {
        // Выбираем меньший элемент и записываем его в исходный массив
        arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
    }

    // Копируем оставшиеся элементы из левого массива
    while (i < n1)
    // Тело цикла копирования остатков левой части
    {
        // Переносим элемент из левого массива в исходный
        arr[k++] = L[i++];
    }

    // Копируем оставшиеся элементы из правого массива
    while (j < n2)
    // Тело цикла копирования остатков правой части
    {
        // Переносим элемент из правого массива в исходный
        arr[k++] = R[j++];
    }
}
// Конец функции merge

// Объявляем рекурсивную функцию сортировки слиянием
static void merge_sort_rec(std::vector<int>& arr, int l, int r)
// Начало функции merge_sort_rec
{
    // Проверяем условие продолжения рекурсии
    if (l < r)
    // Тело условия рекурсии
    {
        // Вычисляем индекс середины массива
        int m = l + (r - l) / 2;

        // Рекурсивно сортируем левую половину массива
        merge_sort_rec(arr, l, m);

        // Рекурсивно сортируем правую половину массива
        merge_sort_rec(arr, m + 1, r);

        // Сливаем две отсортированные половины массива
        merge(arr, l, m, r);
    }
}
// Конец функции merge_sort_rec

// Объявляем внешнюю функцию сортировки слиянием для CPU
void cpu_merge_sort(std::vector<int>& arr)
// Начало функции cpu_merge_sort
{
    // Запускаем рекурсивную сортировку всего массива
    merge_sort_rec(arr, 0, arr.size() - 1);
}
// Конец функции cpu_merge_sort

//
// ======================= QUICK SORT =======================
//

// Объявляем функцию разбиения массива для быстрой сортировки
static int partition(std::vector<int>& arr, int low, int high)
// Начало функции partition
{
    // Выбираем опорный элемент
    int pivot = arr[high];

    // Инициализируем индекс меньшего элемента
    int i = low - 1;

    // Запускаем цикл прохода по массиву
    for (int j = low; j < high; ++j)
    // Тело цикла прохода
    {
        // Проверяем, меньше ли текущий элемент опорного
        if (arr[j] < pivot)
        // Тело условия сравнения
        {
            // Увеличиваем индекс меньшего элемента
            ++i;

            // Сохраняем значение временно
            int temp = arr[i];

            // Перемещаем элемент
            arr[i] = arr[j];

            // Завершаем обмен
            arr[j] = temp;
        }
    }

    // Сохраняем значение для финального обмена
    int temp = arr[i + 1];

    // Перемещаем опорный элемент
    arr[i + 1] = arr[high];

    // Завершаем финальный обмен
    arr[high] = temp;

    // Возвращаем позицию опорного элемента
    return i + 1;
}
// Конец функции partition

// Объявляем рекурсивную функцию быстрой сортировки
static void quick_sort_rec(std::vector<int>& arr, int low, int high)
// Начало функции quick_sort_rec
{
    // Проверяем условие рекурсии
    if (low < high)
    // Тело условия рекурсии
    {
        // Выполняем разбиение массива
        int pi = partition(arr, low, high);

        // Сортируем левую часть массива
        quick_sort_rec(arr, low, pi - 1);

        // Сортируем правую часть массива
        quick_sort_rec(arr, pi + 1, high);
    }
}
// Конец функции quick_sort_rec

// Объявляем внешнюю функцию быстрой сортировки на CPU
void cpu_quick_sort(std::vector<int>& arr)
// Начало функции cpu_quick_sort
{
    // Запускаем рекурсивную быструю сортировку
    quick_sort_rec(arr, 0, arr.size() - 1);
}
// Конец функции cpu_quick_sort

//
// ======================= HEAP SORT =======================
//

// Объявляем функцию восстановления свойства кучи
static void heapify(std::vector<int>& arr, int n, int i)
// Начало функции heapify
{
    // Считаем текущий элемент наибольшим
    int largest = i;

    // Вычисляем индекс левого потомка
    int left = 2 * i + 1;

    // Вычисляем индекс правого потомка
    int right = 2 * i + 2;

    // Проверяем левый потомок
    if (left < n && arr[left] > arr[largest])
    // Тело условия проверки левого потомка
    {
        // Обновляем индекс наибольшего элемента
        largest = left;
    }

    // Проверяем правый потомок
    if (right < n && arr[right] > arr[largest])
    // Тело условия проверки правого потомка
    {
        // Обновляем индекс наибольшего элемента
        largest = right;
    }

    // Проверяем, изменился ли корень
    if (largest != i)
    // Тело условия изменения корня
    {
        // Сохраняем значение временно
        int temp = arr[i];

        // Перемещаем больший элемент
        arr[i] = arr[largest];

        // Завершаем обмен
        arr[largest] = temp;

        // Рекурсивно восстанавливаем кучу
        heapify(arr, n, largest);
    }
}
// Конец функции heapify

// Объявляем функцию пирамидальной сортировки на CPU
void cpu_heap_sort(std::vector<int>& arr)
// Начало функции cpu_heap_sort
{
    // Получаем размер массива
    int n = arr.size();

    // Строим кучу
    for (int i = n / 2 - 1; i >= 0; --i)
    // Тело цикла построения кучи
    {
        // Восстанавливаем свойство кучи
        heapify(arr, n, i);
    }

    // Извлекаем элементы из кучи
    for (int i = n - 1; i > 0; --i)
    // Тело цикла извлечения элементов
    {
        // Сохраняем корень временно
        int temp = arr[0];

        // Перемещаем максимальный элемент в конец
        arr[0] = arr[i];

        // Завершаем обмен
        arr[i] = temp;

        // Восстанавливаем кучу
        heapify(arr, i, 0);
    }
}
// Конец функции cpu_heap_sort
