//   Kurmash Zhumagozhayev, ADA-2401M

//   Практическое занятие 2
//   Тема: Параллельная реализация простых алгоритмов сортировки (пузырьком, выбором, вставкой) на CPU с использованием OpenMP
//Цель работы
//  1. Освоить параллельное программирование с использованием OpenMP на CPU.
//  2. Изучить и реализовать базовые алгоритмы сортировки (пузырьком, выбором, вставкой) в параллельном варианте.
//  3. Провести исследование производительности и сравнить параллельные и последовательные реализации.

// Теоретическая часть
// 1. Введение в алгоритмы сортировки
// Алгоритмы сортировки — это базовые алгоритмы в информатике, которые используются для упорядочивания элементов. Некоторые из них, такие как
// сортировка пузырьком, выбором и вставкой, просты для реализации, но менее эффективны для больших объемов данных.

// 1. Сортировка пузырьком (Bubble Sort):
// a. Принцип работы: сравнивает соседние элементы и перемещает больший элемент вправо.
// b. Время выполнения: O(n^2).
// c. Подходит для небольших массивов или частично отсортированных данных.

// 2. Сортировка выбором (Selection Sort):
// a. Принцип работы: находит минимальный элемент и перемещает его в начало массива.
// b. Время выполнения: O(n^2).
// c. Меньше перемещений по сравнению с сортировкой пузырьком, но также менее эффективна на больших массивах.

// 3. Сортировка вставкой (Insertion Sort):
// a. Принцип работы: элементы последовательно перемещаются в отсортированную часть массива.
// b. Время выполнения: O(n^2), но может быть эффективной на небольших или частично отсортированных массивах.


// 2. Параллельное программирование с OpenMP
// OpenMP — это API для параллельного программирования, который позволяет распределить задачи между несколькими потоками на CPU. Для параллельной
// сортировки мы будем использовать директивы OpenMP, чтобы ускорить выполнение алгоритмов.
// 1. Директива #pragma omp parallel for: позволяет распараллелить выполнение цикла, разделяя итерации между потоками.
// 2. reduction: позволяет суммировать значения из разных потоков в одну переменную.
// 3. Особенности использования: некоторые алгоритмы, такие как сортировка вставкой, могут быть трудны для эффективного параллелизма,
// так как их выполнение зависит от последовательного доступа к данным.

// 3. Параллельная реализация сортировок с OpenMP
// ● Сортировка пузырьком: в параллельной реализации можно параллелить внешние циклы, но важно избегать изменений в позициях
// элементов, которые будут влиять на другие итерации.
// ● Сортировка выбором: каждый поток может искать минимальный элемент параллельно.
// ● Сортировка вставкой: алгоритм менее подходит для параллельной реализации из-за зависимости текущего шага от предыдущих.
// Практическая часть


// Задание
// 1. Реализация сортировок без параллелизма:
// Напишите функции для сортировки пузырьком, выбором и вставкой
// без использования OpenMP.
// 2. Параллельная реализация с использованием OpenMP:
// Используйте директивы OpenMP для распараллеливания внешних циклов. Протестируйте производительность каждой сортировки на
// массивах разного размера (например, 1000, 10,000 и 100,000 элементов).
// 3. Сравнение производительности:
// Измерьте время выполнения последовательных и параллельных версий каждой сортировки, используя библиотеку <chrono>.
// Сравните результаты и сделайте выводы.

// __________________________________________________________________________________________________________________________

//Подключаем библиотеку стандартного ввода/вывода данных
#include <iostream>

//Библиотека Контейнер vector для хранения динамического массива
#include <vector>

//Библиотека для измерения времени
#include <algorithm>
#include <chrono>
#include <random>

// Подключение OpenMP
#ifdef _OPENMP

//Если есть OpenMP, включить инструменты
#include <omp.h>

//Завершение проверки наличия OpenMP
#endif

//Использование коротких названий
using namespace std;

// _________________________ Функция генерации случайного массива ____________________________________________

// Функция получает размер массива N и возвращает массив из случайных чисел
vector<int> generateArray(int N) {
    //Cоздание массива из N элементов
    vector<int> arr(N);

    //Рандомный генератор
    random_device rd;

    //Генератор случайных чисел
    mt19937 gen(rd());

    // Диапазон случайчных чисел от 0 до 100 000
    uniform_int_distribution<int> dist(0, 100000);

    //Заполнение массива случайными числами
    for (int i = 0; i < N; ++i) {
        arr[i] = dist(gen);
    }
    //Возвращаем готовый массив
    return arr;
}

//___________________________ Последовательная сортировка ПУЗЫРЬКОМ (Sequential Bubble Sort) __________________________________

// Функция сортировки пузырьком без параллелизма
void bubbleSortSequential(vector<int>& a) {
    //Получаем размер массива
    int n = a.size();

    //Внешний цикл - количество проходов
    for (int i = 0; i < n - 1; ++i) {

        //Внутренний цикл - сравнение соседних элементов
        for (int j = 0; j < n - i - 1; ++j) {

            //Если элементы стоят неправильно
            if (a[j] > a[j + 1]) {

                //Меняем элементы местами
                swap(a[j], a[j + 1]);
            }
        }
    }
}


// _________________  Параллельная сортировка Пузырьком (Parallel Bubble Sort) _____________________________

// Функция параллельной сортировки пузырьком

void bubbleSortParallel(vector<int>& a) {

    //Получаем размер массива
    int n = a.size();

#ifdef _OPENMP
    //Выполняем сортировку в несколько фаз
    for (int phase = 0; phase < n; ++phase) {

        //Паралелльный цикл OpenMP
        #pragma omp parallel for
        for (int i = phase % 2; i < n - 1; i += 2) {

            //Сравниваем соседние элементы
            if (a[i] > a[i + 1]) {

                //Меняем местами
                swap(a[i], a[i + 1]);
            }
        }
    }
#else
    //Если OpenMP недоступен - используем обычную сортировку
    BubbleSortSequential(a);
#endif
}

// ___________________ Последовательная сортировка ВЫБОРОМ (Sequential Selection Sort) ________________________

//Функция последовательной сортировки выбором
void selectionSortSequential(vector<int>& a) {

    //Получаем размер массива
    int n = a.size();

    //Перебираем элементы массива
    for (int i = 0; i < n - 1; ++i) {

        //Считаем текущий элемент минимальным
        int minIndex = i;

        //Ищем минимальный элемент справа
        for (int j = i + 1; j < n; ++j) {

            //Если найден меньший элемент
            if (a[j] < a[minIndex]) {
                minIndex = j;
            }
        }
        //Меняем местами текущий и минимальный элемент
        swap(a[i], a[minIndex]);
    }
}

// ___________________ Паралелльная сортировка ВЫБОРОМ (Parallel Selection Sort) ________________________

//Функция паралелльной сортировки выбором
void selectionSortParallel(vector<int>& a) {

    // Получаем размер массива
    int n = a.size();

#ifdef _OPENMP

    //Перебираем позиции массива
    for (int i = 0; i < n - 1; ++i) {

        int minIndex = i;

        //Параллельный поиск минимума
#pragma omp parallel for
        for (int j = i + 1; j < n; ++j) {

            //Критическая секция - защита общей переменной
#pragma omp critical
            {
                if (a[j] < a[minIndex]) {
                    minIndex = j;
                }
            }
        }

        //Меняем элементы местами
        swap(a[i], a[minIndex]);
    }

#else

    //Если OpenMP нет, используем последовательную сортировку
    selectionSortSequential(a);

#endif
}


// _____________________________________ Последовательная сортировка ВСТАВКОЙ (Sequential Insertion Sort) _________________________

// Функция сортировки вставкой
void insertionSortSequential(vector<int>& a) {
    // Получаем размер массива
    int n = a.size();

    // Начинаем со второго элемента массива
    for (int i = 1; i < n; ++i) {
        // Текущий элемент
        int key = a[i];

        // Индекс элемента слева
        int j = i - 1;

        //  Сдвигаем элементы вправо
        while (j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            j--;
        }

        // Вставляем элемент на нужное место
        a[j + 1] = key;
    }
}

// ______________________________ Параллельная сортировка ВСТАВКОЙ (Parallel Insertion Sort) _________________________

// Функция параллельной сортировки вставкой
void insertionSortParallel(vector<int>& a) {

    //  Используем последовательную версию, так как сортировка вставкой плохо параллелится
    insertionSortSequential(a);
}

// _________________Функция измерения времени ___________________________________

//Универсальная функция измерения времени сортировки
template <typename SortFunc>
double measureTime(SortFunc sortFunc, vector<int>& a) {

    // Запоминаем время начала
    auto start = chrono::high_resolution_clock::now();

    //Выполняем сортировку
    sortFunc(a);

    // Запоминаем время окончания
    auto end = chrono::high_resolution_clock::now();

    // Вычисляем разницу во времени
    chrono::duration<double, milli> diff = end - start;

    //  Возвращаем время в миллисекундах
    return diff.count();
}

//____________Главная Функция ____________________________________________________________

//Функция
int main() {
    // Размеры массивов для тестирования
    vector<int> sizes = {1000, 10000, 100000};

#ifdef _OPENMP

    // Выводим информацию о количестве потоков
    cout << "OpenMP enabled. Threads: "
         << omp_get_max_threads() << "\n\n";
#else
    cout << "OpenMP NOT enabled\n\n";

#endif

    // Перебираем все размеры массивов
    for (int N: sizes) {
        cout << "Array size:" << N << "\n";

        // Генерируем исходный массив
        vector<int> base = generateArray(N);

        // Сортировка ПУЗЫРЬКОМ
        cout << "Bubble Sort:\n";
        cout << "Sequential : "
             <<measureTime(bubbleSortSequential, base) << "ms\n";
        cout << "Parallel : "
             <<measureTime(bubbleSortParallel, base) << "ms\n";

        // Сортировка ВЫБОРОМ
        cout << "Selection Sort:\n";
        cout << "Sequential : "
             <<measureTime(selectionSortSequential, base) << "ms\n";
        cout << "Parallel : "
             <<measureTime(selectionSortParallel, base) << "ms\n";

        // Сортировка ВСТАВКОЙ
        cout << "Insertion Sort:\n";
        cout << "Sequential : "
             <<measureTime(insertionSortSequential, base) << "ms\n";
        cout << "Parallel : "
             <<measureTime(insertionSortParallel, base) << "ms\n";

        cout << "_______________________________\n";
    }

    // Завершаем программу
    return 0;

}