// Подключаем стандартную библиотеку для ввода и вывода данных
#include <iostream>

// Подключаем стандартную библиотеку для работы с динамическими массивами
#include <vector>

// Подключаем стандартную библиотеку для измерения времени выполнения
#include <chrono>

// Подключаем заголовочный файл с объявлениями функций тестирования GPU-структур
#include "structures.h"

// Определяем точку входа в программу
int main()
{
    // Объявляем массив размеров входных данных для проведения серии экспериментов
    int sizes[] = {100000, 1000000};

    // Запускаем цикл по всем заданным размерам массивов
    for (int N : sizes)
    {
        // Выводим в консоль разделительную линию для наглядного оформления результатов
        std::cout << "==============================" << std::endl;

        // Выводим в консоль текущий размер тестируемых данных
        std::cout << "N = " << N << std::endl;

        // Объявляем переменные для хранения времени выполнения операций стека на GPU
        float stack_push, stack_pop;

        // Объявляем переменные для хранения времени выполнения операций очереди на GPU
        float queue_enq, queue_deq;

        // Вызываем функцию тестирования параллельного стека на GPU
        test_stack(N, stack_push, stack_pop);

        // Вызываем функцию тестирования параллельной очереди на GPU
        test_queue(N, queue_enq, queue_deq);

        // Выводим в консоль время выполнения операции добавления элементов в стек на GPU
        std::cout << "GPU Stack push: " << stack_push << " ms" << std::endl;

        // Выводим в консоль время выполнения операции извлечения элементов из стека на GPU
        std::cout << "GPU Stack pop:  " << stack_pop  << " ms" << std::endl;

        // Выводим в консоль время выполнения операции добавления элементов в очередь на GPU
        std::cout << "GPU Queue enqueue: " << queue_enq << " ms" << std::endl;

        // Выводим в консоль время выполнения операции извлечения элементов из очереди на GPU
        std::cout << "GPU Queue dequeue: " << queue_deq << " ms" << std::endl;
    }

    // ================================
    // Блок тестирования последовательных реализаций на CPU
    // ================================
    {
        // Задаём размер данных для тестирования на CPU
        int N = 1000000;

        // Объявляем вектор для реализации стека на CPU
        std::vector<int> stack;

        // Объявляем вектор для реализации очереди на CPU
        std::vector<int> queue;

        // Резервируем память под элементы стека для уменьшения числа перераспределений памяти
        stack.reserve(N);

        // Резервируем память под элементы очереди для уменьшения числа перераспределений памяти
        queue.reserve(N);

        // Фиксируем начальный момент времени для измерения производительности стека на CPU
        auto t1 = std::chrono::high_resolution_clock::now();

        // Последовательно добавляем элементы в стек
        for (int i = 0; i < N; ++i) stack.push_back(i);

        // Последовательно извлекаем элементы из стека
        for (int i = 0; i < N; ++i) stack.pop_back();

        // Фиксируем конечный момент времени для измерения производительности стека на CPU
        auto t2 = std::chrono::high_resolution_clock::now();

        // Вычисляем общее время выполнения операций со стеком на CPU в миллисекундах
        double cpu_stack_ms = std::chrono::duration<double, std::milli>(t2 - t1).count();

        // Фиксируем начальный момент времени для измерения производительности очереди на CPU
        t1 = std::chrono::high_resolution_clock::now();

        // Последовательно добавляем элементы в очередь
        for (int i = 0; i < N; ++i) queue.push_back(i);

        // Последовательно удаляем элементы из начала очереди
        for (int i = 0; i < N; ++i) queue.erase(queue.begin());

        // Фиксируем конечный момент времени для измерения производительности очереди на CPU
        t2 = std::chrono::high_resolution_clock::now();

        // Вычисляем общее время выполнения операций с очередью на CPU в миллисекундах
        double cpu_queue_ms = std::chrono::duration<double, std::milli>(t2 - t1).count();

        // Выводим в консоль разделительную линию для отделения результатов CPU-тестов
        std::cout << "==============================" << std::endl;

        // Выводим в консоль суммарное время выполнения операций со стеком на CPU
        std::cout << "CPU Stack total: " << cpu_stack_ms << " ms" << std::endl;

        // Выводим в консоль суммарное время выполнения операций с очередью на CPU
        std::cout << "CPU Queue total: " << cpu_queue_ms << " ms" << std::endl;
    }

    // Возвращаем код успешного завершения программы
    return 0;
}
