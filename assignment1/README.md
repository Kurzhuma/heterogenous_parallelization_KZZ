# Assignment 1 – C++ & OpenMP

## Общая информация
Цель Assignment 1 посвящена изучению основ языка C++ и технологии параллельного программирования OpenMP.  
В работе рассматривается динамическое выделение памяти, последовательная и параллельная обработка массивов, а также сравнение времени выполнения алгоритмов.

Работа выполнена в среде CLion с использованием компилятора GCC и поддержкой OpenMP.

---

## Цель работы
- Освоить динамическое выделение и освобождение памяти в C++
- Реализовать последовательные алгоритмы обработки массивов
- Реализовать параллельные алгоритмы с использованием OpenMP
- Сравнить производительность последовательных и параллельных реализаций

---

## Используемые технологии
- Язык программирования: C++
- Параллельное программирование: OpenMP
- Измерение времени: `std::chrono`
- Среда разработки: CLion
- Компилятор: GCC

---

## Описание заданий

### Задание 1
Динамически выделить массив из 50 000 целых чисел, заполнить его случайными значениями в диапазоне от 1 до 100, вычислить среднее значение элементов массива и корректно освободить выделенную память.

### Задание 2
Создать массив из 1 000 000 целых чисел и реализовать последовательный алгоритм поиска минимального и максимального элементов массива. Замерить время выполнения алгоритма.

### Задание 3
С использованием технологии OpenMP реализовать параллельный поиск минимального и максимального элементов массива из задания 2 и сравнить время выполнения с последовательной версией.

### Задание 4
Создать массив из 5 000 000 целых чисел и реализовать вычисление среднего значения элементов массива:
- последовательным способом;
- параллельным способом с использованием механизма `reduction` в OpenMP.  
  Сравнить время выполнения обеих реализаций.

---

## Результаты выполнения

Результаты запуска программы:

Task 1 - Average value: 50.442
Task 2 - Sequential Min: 0
Task 2 - Sequential Max: 32767
Task 2 - Sequential Time: 0.0023186 s
Task 3 - Parallel Min: 0
Task 3 - Parallel Max: 32767
Task 3 - Parallel Time: 0.0012616 s
Task 4 - Sequential Average: 49.4568
Task 4 - Sequential Time: 0.0109135 s
Task 4 - Parallel Average: 49.4568
Task 4 - Parallel Time: 0.0028257 s!

[img.png](img.png)
![output.png](output.png)

## Блок схема


![Assignment1_block_scheme.png](Assignment1_block_scheme.png)
---

## Анализ результатов
- Параллельная реализация поиска минимального и максимального элементов показала меньшее время выполнения по сравнению с последовательной.
- При вычислении среднего значения массива ускорение параллельной версии выражено более значительно.
- Использование одного и того же массива для последовательных и параллельных алгоритмов обеспечивает корректность сравнения времени выполнения.


---

## Контрольные вопросы и ответы

### 1. В чем отличие динамического массива от статического массива в языке C++?
Статический массив имеет фиксированный размер, известный на этапе компиляции, и размещается в стеке или статической области памяти.  
Динамический массив создается во время выполнения программы, размещается в куче и позволяет задавать размер массива во время работы программы.

---

### 2. Что такое указатель и зачем он используется при работе с динамической памятью?
Указатель — это переменная, которая хранит адрес в памяти.  
При работе с динамической памятью указатель используется для доступа к области памяти, выделенной с помощью оператора `new`.

---

### 3. Почему важно корректно освобождать память после использования динамических массивов?
Неосвобожденная динамическая память приводит к утечкам памяти, увеличению потребления ресурсов и потенциальной нестабильной работе программы.

---

### 4. В чем разница между последовательной и параллельной обработкой массива?
Последовательная обработка выполняется одним потоком по очереди.  
Параллельная обработка распределяет вычисления между несколькими потоками, что позволяет сократить общее время выполнения.

---

### 5. Что делает директива `#pragma omp parallel for`?
Данная директива распараллеливает цикл `for`, распределяя итерации цикла между несколькими потоками.

---

### 6. Для чего используется механизм `reduction` в OpenMP?
Механизм `reduction` используется для безопасного объединения частичных результатов, вычисленных разными потоками, в одно итоговое значение.

---

### 7. Почему при параллельном вычислении суммы необходимо использовать `reduction`, а не обычную переменную?
Использование обычной переменной приводит к состоянию гонки.  
`reduction` создает локальные копии переменной для каждого потока и корректно объединяет их после завершения параллельной области.

---

### 8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?
- Небольшой размер обрабатываемых данных
- Накладные расходы на создание и синхронизацию потоков
- Ограниченное количество процессорных ядер
- Неравномерное распределение нагрузки
- Ограничения пропускной способности памяти

---
