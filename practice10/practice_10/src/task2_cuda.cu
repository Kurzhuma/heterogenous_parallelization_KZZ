/**
 * ЗАДАНИЕ 2. ОПТИМИЗАЦИЯ ДОСТУПА К ПАМЯТИ НА GPU (CUDA)
 */

// Подключение стандартной библиотеки ввода-вывода
#include <iostream>
// Подключение заголовочного файла среды выполнения CUDA
#include <cuda_runtime.h>
// Подключение системной библиотеки для настройки консоли Windows
#include <windows.h>
// Подключение вспомогательных утилит для обработки ошибок CUDA
#include "utils.h"

// Ядро с неэффективным доступом (разрывный паттерн, но полная нагрузка)
__global__ void non_coalesced_kernel(float* data, int n) {
    // Используем перестановку индекса: потоки одной группы (warpa)
    // будут запрашивать данные из разных сегментов памяти
    int i = (threadIdx.x * 32 + blockIdx.x * blockDim.x) % n;
    if (i < n) data[i] *= 2.0f;
    }


// Глобальная функция (ядро) для реализации эффективного доступа к памяти
__global__ void coalesced_kernel(float* data, int n) {
    // Расчет линейного последовательного индекса для каждого потока
    int i = blockIdx.x * blockDim.x + threadIdx.x;
    // Условие для предотвращения выхода за пределы массива
    if (i < n) {
        // Прямое модифицирование значения в памяти
        data[i] = data[i] * 2.0f;
    }
}

int main() {
    // Настройка кодировки UTF-8 для вывода кириллицы без искажений
    SetConsoleOutputCP(65001);

    // Определение количества обрабатываемых элементов (2 в 28-й степени)
    const int N = 1 << 28;
    // Объявление указателя на массив в памяти графического устройства
    float *d_data;
    // Выделение видеопамяти с учетом максимального смещения при неэффективном доступе
    CHECK_CUDA(cudaMalloc(&d_data, N * 32 * sizeof(float)));

    // Инициализация событий CUDA для замера времени выполнения ядер
    cudaEvent_t start, stop;
    // Резервирование ресурсов под события синхронизации
    CHECK_CUDA(cudaEventCreate(&start));
    CHECK_CUDA(cudaEventCreate(&stop));

    // Регистрация события начала выполнения коалесцированного ядра
    CHECK_CUDA(cudaEventRecord(start));
    // Запуск эффективного ядра с оптимальной конфигурацией сетки и блоков
    coalesced_kernel<<<(N + 255) / 256, 256>>>(d_data, N);
    // Регистрация события окончания выполнения и синхронизация устройства
    CHECK_CUDA(cudaEventRecord(stop));
    CHECK_CUDA(cudaEventSynchronize(stop));

    // Переменная для хранения длительности выполнения в миллисекундах
    float ms_eff = 0;
    // Вычисление интервала времени между событиями начала и конца
    cudaEventElapsedTime(&ms_eff, start, stop);

    // Регистрация начала замера для неэффективного паттерна доступа
    CHECK_CUDA(cudaEventRecord(start));
    // Запуск ядра с шагом 32, что приводит к разрозненным транзакциям памяти
    non_coalesced_kernel<<<(N + 255) / 256, 256>>>(d_data, N, 32);
    // Ожидание завершения всех операций на GPU
    CHECK_CUDA(cudaEventRecord(stop));
    CHECK_CUDA(cudaEventSynchronize(stop));

    // Переменная для хранения времени неэффективного выполнения
    float ms_ineff = 0;
    // Расчет времени выполнения для разрывного доступа
    cudaEventElapsedTime(&ms_ineff, start, stop);

    // Вывод аналитических результатов сравнения производительности
    std::cout << "Время эффективного (Coalesced) доступа: " << ms_eff << " мс" << std::endl;
    std::cout << "Время неэффективного (Stride 32) доступа: " << ms_ineff << " мс" << std::endl;
    // Отображение коэффициента замедления при неправильной организации данных
    std::cout << "Замедление при неэффективном доступе: " << ms_ineff / ms_eff << "x" << std::endl;

    // Освобождение ранее выделенной видеопамяти
    cudaFree(d_data);
    // Уничтожение объектов событий CUDA
    cudaEventDestroy(start);
    cudaEventDestroy(stop);

    return 0;
}