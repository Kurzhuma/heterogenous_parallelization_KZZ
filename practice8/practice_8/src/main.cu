/**
 * ПРАКТИЧЕСКАЯ РАБОТА №8: РАЗРАБОТКА ГИБРИДНОГО ПРИЛОЖЕНИЯ
 * Задачи: Сравнение производительности CPU, GPU и гибридного режима.
 */

// Подключение стандартной библиотеки ввода-вывода
#include <stdio.h>
// Подключение стандартной библиотеки функций
#include <stdlib.h>
// Подключение заголовочных файлов среды выполнения CUDA
#include <cuda_runtime.h>
// Подключение библиотеки OpenMP для многопоточности на CPU
#include <omp.h>
// Подключение системных функций Windows для работы с кодировкой
#include <windows.h>
// Подключение вспомогательных утилитарных функций проекта
#include "utils.h"

// Определение размера блока потоков для видеокарты
#define BLOCK_SIZE 256

// ============================================================================
// ЗАДАНИЕ 1: ОБРАБОТКА НА CPU (OpenMP)
// ============================================================================

/**
 * Функция обработки сегмента массива на центральном процессоре
 */
// Определение функции для параллельной обработки данных на стороне хоста
void processCPU(float* data, size_t start, size_t end) {
    // Использование директивы OpenMP для распределения итераций цикла по ядрам CPU
    #pragma omp parallel for
    for (size_t i = start; i < end; i++) {
        // Выполнение арифметической операции над элементом массива
        data[i] = data[i] * 2.0f;
    }
}

// ============================================================================
// ЗАДАНИЕ 2: ОБРАБОТКА НА GPU (CUDA)
// ============================================================================

/**
 * CUDA-ядро для обработки элементов массива в видеопамяти
 */
// Определение ядра CUDA, исполняемого на графическом процессоре
__global__ void processGPUKernel(float* data, size_t n) {
    // Вычисление уникального глобального индекса элемента для каждого потока
    size_t i = blockIdx.x * blockDim.x + threadIdx.x;
    // Проверка индекса на соответствие границам обрабатываемого массива
    if (i < n) {
        // Модификация значения элемента непосредственно в видеопамяти
        data[i] = data[i] * 2.0f;
    }
}

// ============================================================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================================================

/**
 * Инициализация массива значениями 1.0f
 */
// Определение функции сброса данных в массиве перед началом каждого теста
void resetData(float* data, size_t n) {
    // Последовательное заполнение массива единицами
    for (size_t i = 0; i < n; i++) data[i] = 1.0f;
}

// ============================================================================
// ГЛАВНАЯ ФУНКЦИЯ
// ============================================================================

int main() {
    // Установка кодировки UTF-8 в консоли Windows для корректного отображения текста
    SetConsoleOutputCP(65001);

    // Определение общего количества элементов в массиве (10 миллионов)
    const size_t N = 10000000;
    // Вычисление необходимого размера памяти в байтах
    size_t bytes = N * sizeof(float);

    // Резервирование оперативной памяти на стороне центрального процессора
    float *h_data = (float*)malloc(bytes);

    // Вывод информации о начале выполнения практической работы
    printf("=== ПРАКТИЧЕСКАЯ РАБОТА №8: ГИБРИДНЫЕ ВЫЧИСЛЕНИЯ ===\n");
    // Информирование пользователя о размере обрабатываемых данных
    printf("Размер массива: %zu элементов\n\n", N);

    // ------------------------------------------------------------------------
    // ЗАДАНИЕ 1: ТОЛЬКО CPU
    // ------------------------------------------------------------------------
    // Подготовка данных для первого испытания
    resetData(h_data, N);
    // Фиксация времени начала выполнения последовательного/OpenMP алгоритма
    double t_start = omp_get_wtime();

    // Запуск многопоточной обработки всего массива на CPU
    processCPU(h_data, 0, N);

    // Фиксация времени окончания работы центрального процессора
    double t_end = omp_get_wtime();
    // Расчет длительности обработки на CPU в миллисекундах
    double cpu_time = (t_end - t_start) * 1000.0;
    // Вывод результатов первого задания
    printf("[ЗАДАНИЕ 1] Только CPU (OpenMP): %10.4f ms\n", cpu_time);

    // ------------------------------------------------------------------------
    // ЗАДАНИЕ 2: ТОЛЬКО GPU
    // ------------------------------------------------------------------------
    // Подготовка данных для второго испытания
    resetData(h_data, N);
    // Объявление указателя для размещения данных в видеопамяти
    float *d_data_only;
    // Замер времени начала выполнения операций на графическом ускорителе
    t_start = omp_get_wtime();

    // Выделение глобальной видеопамяти на устройстве
    CHECK_CUDA(cudaMalloc(&d_data_only, bytes));
    // Копирование исходного массива из оперативной памяти в видеопамять
    CHECK_CUDA(cudaMemcpy(d_data_only, h_data, bytes, cudaMemcpyHostToDevice));

    // Определение количества блоков в сетке на основе размера массива
    int blocks = (N + BLOCK_SIZE - 1) / BLOCK_SIZE;
    // Конфигурация запуска и активация вычислительного ядра на GPU
    processGPUKernel<<<blocks, BLOCK_SIZE>>>(d_data_only, N);

    // Ожидание завершения всех параллельных вычислений на видеокарте
    CHECK_CUDA(cudaDeviceSynchronize());
    // Перенос модифицированных данных обратно в оперативную память хоста
    CHECK_CUDA(cudaMemcpy(h_data, d_data_only, bytes, cudaMemcpyDeviceToHost));

    // Фиксация времени окончания GPU-теста
    t_end = omp_get_wtime();
    // Расчет времени выполнения, включающего запуск ядра и пересылки данных
    double gpu_time = (t_end - t_start) * 1000.0;
    // Вывод результатов второго задания
    printf("[ЗАДАНИЕ 2] Только GPU (CUDA):   %10.4f ms\n", gpu_time);
    // Освобождение ресурсов видеопамяти
    cudaFree(d_data_only);


    // ------------------------------------------------------------------------
    // ЗАДАНИЕ 3: ГИБРИДНАЯ ОБРАБОТКА (ОДНОВРЕМЕННО)
    // ------------------------------------------------------------------------
    // Подготовка данных для третьего испытания
    resetData(h_data, N);
    // Расчет индекса разделения массива на две равные части
    size_t half = N / 2;
    // Определение объема памяти для половины массива
    size_t halfBytes = half * sizeof(float);
    // Объявление указателя для гибридной обработки данных на GPU
    float *d_data_hybrid;

    // Начало замера времени для комбинированного режима работы
    t_start = omp_get_wtime();

    // Резервирование видеопамяти для обработки второй половины данных
    CHECK_CUDA(cudaMalloc(&d_data_hybrid, halfBytes));

    // Копирование второй половины массива в видеопамять устройства
    CHECK_CUDA(cudaMemcpy(d_data_hybrid, &h_data[half], halfBytes, cudaMemcpyHostToDevice));

    // Параллельный запуск: CPU начинает обработку своей половины через OpenMP
    processCPU(h_data, 0, half);

    // Одновременный запуск ядра на GPU для обработки оставшейся половины данных
    int hybridBlocks = (half + BLOCK_SIZE - 1) / BLOCK_SIZE;
    processGPUKernel<<<hybridBlocks, BLOCK_SIZE>>>(d_data_hybrid, half);

    // Барьерная синхронизация: ожидание завершения работы графического ускорителя
    CHECK_CUDA(cudaDeviceSynchronize());

    // Копирование результирующей половины данных из GPU обратно в хост-память
    CHECK_CUDA(cudaMemcpy(&h_data[half], d_data_hybrid, halfBytes, cudaMemcpyDeviceToHost));

    // Фиксация времени завершения гибридной обработки
    t_end = omp_get_wtime();
    // Расчет суммарного времени выполнения в гибридном режиме
    double hybrid_time = (t_end - t_start) * 1000.0;
    // Вывод результатов третьего задания
    printf("[ЗАДАНИЕ 3] Гибридный режим:      %10.4f ms\n", hybrid_time);

    // ------------------------------------------------------------------------
    // ЗАДАНИЕ 4: АНАЛИЗ УСКОРЕНИЯ
    // ------------------------------------------------------------------------
    // Формирование заголовка аналитического блока
    printf("\n=== АНАЛИЗ ПРОИЗВОДИТЕЛЬНОСТИ ===\n");
    // Вычисление и вывод коэффициента ускорения относительно CPU
    printf("Ускорение Гибрид vs CPU: %.2fx\n", cpu_time / hybrid_time);
    // Вычисление и вывод коэффициента ускорения относительно GPU
    printf("Ускорение Гибрид vs GPU: %.2fx\n", gpu_time / hybrid_time);

    // Очистка выделенной памяти на устройстве
    cudaFree(d_data_hybrid);
    // Очистка выделенной оперативной памяти на хосте
    free(h_data);

    // Завершение работы программы
    return 0;
}